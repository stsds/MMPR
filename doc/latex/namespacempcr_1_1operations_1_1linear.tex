\hypertarget{namespacempcr_1_1operations_1_1linear}{}\doxysection{mpcr\+::operations\+::linear Namespace Reference}
\label{namespacempcr_1_1operations_1_1linear}\index{mpcr::operations::linear@{mpcr::operations::linear}}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacempcr_1_1operations_1_1linear_a4d6e3d438dd9fcd8f4cdc5a8e537a8da}{Cross\+Product}} (\mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{MathematicalOperations_8cpp_ac5a8b6d5d0c66319ea2bd9dd9a1234b0}{a\+InputA}}, \mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{LinearAlgebra_8cpp_af29c585d74852408757764cc58b8b6fd}{a\+InputB}}, \mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{MathematicalOperations_8cpp_a85b97edf08d7990be4db36a27114c234}{a\+Output}}, const bool \&a\+TransposeA, const bool \&a\+TransposeB, const bool \&a\+Symmetrize=true, const double \&a\+Alpha=1, const double \&a\+Beta=0)
\begin{DoxyCompactList}\small\item\em Calculate Cross\+Product of 2 M\+P\+CR Matrices performs\+: x \%$\ast$\% t(x) , x \%$\ast$\% t(y) , x \%$\ast$\% y , t(x) \%$\ast$\% y. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacempcr_1_1operations_1_1linear_ad56ba3c059d0ecb871efdad87bc10049}{Is\+Symmetric}} (\mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{LinearAlgebra_8cpp_a6d72f94b92fb4d87ccc1626e60e28b4d}{a\+Input}}, bool \&\mbox{\hyperlink{MathematicalOperations_8cpp_a85b97edf08d7990be4db36a27114c234}{a\+Output}})
\begin{DoxyCompactList}\small\item\em Check if a Matrix Is Symmetric. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacempcr_1_1operations_1_1linear_a9b4a2fb4286fd0d4e519b8361da69411}{Cholesky}} (\mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{MathematicalOperations_8cpp_ac5a8b6d5d0c66319ea2bd9dd9a1234b0}{a\+InputA}}, \mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{MathematicalOperations_8cpp_a85b97edf08d7990be4db36a27114c234}{a\+Output}}, const bool \&a\+Upper\+Triangle=true)
\begin{DoxyCompactList}\small\item\em Calculate Cholesky decomposition. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacempcr_1_1operations_1_1linear_aeb698c5e2520150713bae4d109e3a682}{Cholesky\+Inv}} (\mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{MathematicalOperations_8cpp_ac5a8b6d5d0c66319ea2bd9dd9a1234b0}{a\+InputA}}, \mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{MathematicalOperations_8cpp_a85b97edf08d7990be4db36a27114c234}{a\+Output}}, const size\+\_\+t \&a\+N\+Col)
\begin{DoxyCompactList}\small\item\em Invert a symmetric, positive definite square matrix from its Cholesky decomposition. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacempcr_1_1operations_1_1linear_adbbaafc06cebed29879351524a5982da}{Solve}} (\mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{MathematicalOperations_8cpp_ac5a8b6d5d0c66319ea2bd9dd9a1234b0}{a\+InputA}}, \mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{LinearAlgebra_8cpp_af29c585d74852408757764cc58b8b6fd}{a\+InputB}}, \mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{MathematicalOperations_8cpp_a85b97edf08d7990be4db36a27114c234}{a\+Output}}, const bool \&a\+Single)
\begin{DoxyCompactList}\small\item\em Solves the equation AX=B. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacempcr_1_1operations_1_1linear_a9f4c43dc1b2e4c0abfd93e6991bb256a}{Back\+Solve}} (\mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{MathematicalOperations_8cpp_ac5a8b6d5d0c66319ea2bd9dd9a1234b0}{a\+InputA}}, \mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{LinearAlgebra_8cpp_af29c585d74852408757764cc58b8b6fd}{a\+InputB}}, \mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{MathematicalOperations_8cpp_a85b97edf08d7990be4db36a27114c234}{a\+Output}}, const size\+\_\+t \&a\+Col, const bool \&a\+Upper\+Tri, const bool \&a\+Transpose, const char \&a\+Side=\textquotesingle{}L\textquotesingle{}, const double \&a\+Alpha=1)
\begin{DoxyCompactList}\small\item\em Solves a system of linear equations where the coefficient matrix is upper or lower triangular. Solve a\+InputA a\+Output = a\+InputB. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacempcr_1_1operations_1_1linear_a52bdf8f12e8169bb9f88fe3b5aaf0aac}{Eigen}} (\mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{LinearAlgebra_8cpp_a6d72f94b92fb4d87ccc1626e60e28b4d}{a\+Input}}, \mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{LinearAlgebra_8cpp_a1e31bff9dc24cac34192d5139f03d1fe}{a\+Output\+Values}}, \mbox{\hyperlink{classDataType}{Data\+Type}} $\ast$ap\+Output\+Vectors=nullptr)
\begin{DoxyCompactList}\small\item\em Calculate Eigen Values and (optionally) Eigen Vectors. if(ap\+Output\+Vectors)= nullptr , only the values will be calculated. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacempcr_1_1operations_1_1linear_a3dcaf6bd7a11a06db70d4e1097af99b4}{Norm}} (\mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{LinearAlgebra_8cpp_a6d72f94b92fb4d87ccc1626e60e28b4d}{a\+Input}}, const std\+::string \&a\+Type, \mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{MathematicalOperations_8cpp_a85b97edf08d7990be4db36a27114c234}{a\+Output}})
\begin{DoxyCompactList}\small\item\em Computes a matrix norm of a\+Input. The norm can be the one (\char`\"{}\+O\char`\"{}) norm, the infinity (\char`\"{}\+I\char`\"{}) norm, the Frobenius (\char`\"{}\+F\char`\"{}) norm, or the maximum modulus (\char`\"{}\+M\char`\"{}) among elements of a matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacempcr_1_1operations_1_1linear_a77142d0bbe9c5b3409bf89ea97f74818}{Q\+R\+Decomposition}} (\mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{MathematicalOperations_8cpp_ac5a8b6d5d0c66319ea2bd9dd9a1234b0}{a\+InputA}}, \mbox{\hyperlink{classDataType}{Data\+Type}} \&a\+Output\+Qr, \mbox{\hyperlink{classDataType}{Data\+Type}} \&a\+Output\+Qraux, \mbox{\hyperlink{classDataType}{Data\+Type}} \&a\+Output\+Pivot, \mbox{\hyperlink{classDataType}{Data\+Type}} \&a\+Rank, const double \&a\+Tolerance=1e-\/07)
\begin{DoxyCompactList}\small\item\em Computes the QR decomposition of a matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacempcr_1_1operations_1_1linear_ac609806ecdb032bdfbca40e7ac8e6d5c}{Q\+R\+DecompositionR}} (\mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{MathematicalOperations_8cpp_ac5a8b6d5d0c66319ea2bd9dd9a1234b0}{a\+InputA}}, \mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{MathematicalOperations_8cpp_a85b97edf08d7990be4db36a27114c234}{a\+Output}}, const bool \&a\+Complete)
\begin{DoxyCompactList}\small\item\em returns R. This may be pivoted, The number of rows of R is either nrow(a\+Input\+A) or ncol(a\+Input\+A) (and may depend on whether complete is T\+R\+UE or F\+A\+L\+SE). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacempcr_1_1operations_1_1linear_a27b933e2aebb6707f2b4ad8a843fa2ee}{Q\+R\+DecompositionQ}} (\mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{MathematicalOperations_8cpp_ac5a8b6d5d0c66319ea2bd9dd9a1234b0}{a\+InputA}}, \mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{LinearAlgebra_8cpp_af29c585d74852408757764cc58b8b6fd}{a\+InputB}}, \mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{MathematicalOperations_8cpp_a85b97edf08d7990be4db36a27114c234}{a\+Output}}, const bool \&a\+Complete)
\begin{DoxyCompactList}\small\item\em Returns part or all of Q, the order-\/nrow(X) orthogonal (unitary) transformation represented by qr. If complete is T\+R\+UE, Q has nrow(\+X) columns. If complete is F\+A\+L\+SE, Q has ncol(\+X) columns. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacempcr_1_1operations_1_1linear_a903f45dc4c56fd063be9fcb41de60229}{Q\+R\+Decomposition\+QY}} (\mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{MathematicalOperations_8cpp_ac5a8b6d5d0c66319ea2bd9dd9a1234b0}{a\+InputA}}, \mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{LinearAlgebra_8cpp_af29c585d74852408757764cc58b8b6fd}{a\+InputB}}, \mbox{\hyperlink{classDataType}{Data\+Type}} \&a\+InputC, \mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{MathematicalOperations_8cpp_a85b97edf08d7990be4db36a27114c234}{a\+Output}}, const bool \&a\+Transpose)
\begin{DoxyCompactList}\small\item\em Returns part or all of Q, the order-\/nrow(X) orthogonal (unitary) transformation represented by qr. If complete is T\+R\+UE, Q has nrow(\+X) columns. If complete is F\+A\+L\+SE, Q has ncol(\+X) columns. and each column of Q is multiplied by the corresponding value in Dvec. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacempcr_1_1operations_1_1linear_a9085cca6610c2c87cdf93eaf781ef893}{S\+VD}} (\mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{MathematicalOperations_8cpp_ac5a8b6d5d0c66319ea2bd9dd9a1234b0}{a\+InputA}}, \mbox{\hyperlink{classDataType}{Data\+Type}} \&a\+OutputS, \mbox{\hyperlink{classDataType}{Data\+Type}} \&a\+OutputU, \mbox{\hyperlink{classDataType}{Data\+Type}} \&a\+OutputV, const size\+\_\+t \&a\+Nu, const size\+\_\+t \&a\+Nv, const bool \&a\+Transpose=true)
\begin{DoxyCompactList}\small\item\em Compute the singular-\/value decomposition of a rectangular matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacempcr_1_1operations_1_1linear_ad3df9b11fb2ef85bb83b45fa48e1b220}{Reciprocal\+Condition}} (\mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{LinearAlgebra_8cpp_a6d72f94b92fb4d87ccc1626e60e28b4d}{a\+Input}}, \mbox{\hyperlink{classDataType}{Data\+Type}} \&\mbox{\hyperlink{MathematicalOperations_8cpp_a85b97edf08d7990be4db36a27114c234}{a\+Output}}, const std\+::string \&\mbox{\hyperlink{LinearAlgebra_8cpp_ad35e7bb2ad3a18c735dba2a03e92c7f4}{a\+Norm}}, const bool \&a\+Triangle)
\begin{DoxyCompactList}\small\item\em Estimate the reciprocal of the condition number of a matrix. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classMPCRTile}{M\+P\+C\+R\+Tile}} $\ast$ \mbox{\hyperlink{namespacempcr_1_1operations_1_1linear_a5c8f7cdb592e0cb4a820d88af7105d22}{Tile\+Cholesky}} (\mbox{\hyperlink{classMPCRTile}{M\+P\+C\+R\+Tile}} \&a\+Matrix, const bool \&a\+Over\+Write\+Input=true, const unsigned int \&a\+Num\+Threads=1)
\begin{DoxyCompactList}\small\item\em Calculate Cholesky decomposition for Tiled-\/\+Symmetric Matrix. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacempcr_1_1operations_1_1linear_abf947d90eb7b44b63653c9078e7f41a5}{Tile\+Gemm}} (\mbox{\hyperlink{classMPCRTile}{M\+P\+C\+R\+Tile}} \&\mbox{\hyperlink{MathematicalOperations_8cpp_ac5a8b6d5d0c66319ea2bd9dd9a1234b0}{a\+InputA}}, \mbox{\hyperlink{classMPCRTile}{M\+P\+C\+R\+Tile}} \&\mbox{\hyperlink{LinearAlgebra_8cpp_af29c585d74852408757764cc58b8b6fd}{a\+InputB}}, \mbox{\hyperlink{classMPCRTile}{M\+P\+C\+R\+Tile}} \&a\+InputC, const bool \&a\+TransposeA=false, const bool \&a\+TransposeB=false, const double \&a\+Alpha=1, const double \&a\+Beta=1, const unsigned int \&a\+Num\+Threads=1)
\begin{DoxyCompactList}\small\item\em Tiled-\/\+Matrix Multiplication of 2 M\+P\+CR Tile Matrices performs\+: C = alpha A $\ast$ B + beta C. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacempcr_1_1operations_1_1linear_a7d47126a1945fd0a6fd28af51ebd9f77}{Tile\+Trsm}} (\mbox{\hyperlink{classMPCRTile}{M\+P\+C\+R\+Tile}} \&\mbox{\hyperlink{MathematicalOperations_8cpp_ac5a8b6d5d0c66319ea2bd9dd9a1234b0}{a\+InputA}}, \mbox{\hyperlink{classMPCRTile}{M\+P\+C\+R\+Tile}} \&\mbox{\hyperlink{LinearAlgebra_8cpp_af29c585d74852408757764cc58b8b6fd}{a\+InputB}}, const char \&a\+Side, const bool \&a\+Upper\+Triangle, const bool \&a\+Transpose, const double \&a\+Alpha)
\begin{DoxyCompactList}\small\item\em Solves a triangular matrix equation performs\+: op(\+A)$\ast$X=alpha$\ast$B X$\ast$op(A)=alpha$\ast$B. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespacempcr_1_1operations_1_1linear_a9f4c43dc1b2e4c0abfd93e6991bb256a}\label{namespacempcr_1_1operations_1_1linear_a9f4c43dc1b2e4c0abfd93e6991bb256a}} 
\index{mpcr::operations::linear@{mpcr::operations::linear}!BackSolve@{BackSolve}}
\index{BackSolve@{BackSolve}!mpcr::operations::linear@{mpcr::operations::linear}}
\doxysubsubsection{\texorpdfstring{BackSolve()}{BackSolve()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void mpcr\+::operations\+::linear\+::\+Back\+Solve (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+InputA,  }\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+InputB,  }\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+Output,  }\item[{const size\+\_\+t \&}]{a\+Col,  }\item[{const bool \&}]{a\+Upper\+Tri,  }\item[{const bool \&}]{a\+Transpose,  }\item[{const char \&}]{a\+Side = {\ttfamily \textquotesingle{}L\textquotesingle{}},  }\item[{const double \&}]{a\+Alpha = {\ttfamily 1} }\end{DoxyParamCaption})}



Solves a system of linear equations where the coefficient matrix is upper or lower triangular. Solve a\+InputA a\+Output = a\+InputB. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em a\+InputA} & M\+P\+CR Matrix \\
\hline
\mbox{\texttt{ in}}  & {\em a\+InputB} & M\+P\+CR Matrix \\
\hline
\mbox{\texttt{ out}}  & {\em a\+Output} & The solution of the triangular system \\
\hline
\mbox{\texttt{ in}}  & {\em a\+Col} & The number of columns of a\+InputA and rows of a\+InputB to use. \\
\hline
\mbox{\texttt{ in}}  & {\em a\+Upper\+Tri} & logical; if true (default), the upper triangular part of a\+InputA is used. Otherwise, the lower one. \\
\hline
\mbox{\texttt{ in}}  & {\em a\+Transpose} & logical; if true, solve for t(a\+Input\+A) \%$\ast$\% a\+Output == a\+InputB. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_a9f4c43dc1b2e4c0abfd93e6991bb256a_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_a9f4c43dc1b2e4c0abfd93e6991bb256a_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacempcr_1_1operations_1_1linear_a9b4a2fb4286fd0d4e519b8361da69411}\label{namespacempcr_1_1operations_1_1linear_a9b4a2fb4286fd0d4e519b8361da69411}} 
\index{mpcr::operations::linear@{mpcr::operations::linear}!Cholesky@{Cholesky}}
\index{Cholesky@{Cholesky}!mpcr::operations::linear@{mpcr::operations::linear}}
\doxysubsubsection{\texorpdfstring{Cholesky()}{Cholesky()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void mpcr\+::operations\+::linear\+::\+Cholesky (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+InputA,  }\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+Output,  }\item[{const bool \&}]{a\+Upper\+Triangle = {\ttfamily true} }\end{DoxyParamCaption})}



Calculate Cholesky decomposition. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em a\+Input} & M\+P\+CR Matrix \\
\hline
\mbox{\texttt{ out}}  & {\em a\+Output} & M\+P\+CR Matrix containing decomposition result \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_a9b4a2fb4286fd0d4e519b8361da69411_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_a9b4a2fb4286fd0d4e519b8361da69411_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacempcr_1_1operations_1_1linear_aeb698c5e2520150713bae4d109e3a682}\label{namespacempcr_1_1operations_1_1linear_aeb698c5e2520150713bae4d109e3a682}} 
\index{mpcr::operations::linear@{mpcr::operations::linear}!CholeskyInv@{CholeskyInv}}
\index{CholeskyInv@{CholeskyInv}!mpcr::operations::linear@{mpcr::operations::linear}}
\doxysubsubsection{\texorpdfstring{CholeskyInv()}{CholeskyInv()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void mpcr\+::operations\+::linear\+::\+Cholesky\+Inv (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+InputA,  }\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+Output,  }\item[{const size\+\_\+t \&}]{a\+N\+Col }\end{DoxyParamCaption})}



Invert a symmetric, positive definite square matrix from its Cholesky decomposition. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em a\+Input} & M\+P\+CR Matrix containing Cholesky decomposition. \\
\hline
\mbox{\texttt{ out}}  & {\em a\+Output} & M\+P\+CR Matrix \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_aeb698c5e2520150713bae4d109e3a682_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_aeb698c5e2520150713bae4d109e3a682_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacempcr_1_1operations_1_1linear_a4d6e3d438dd9fcd8f4cdc5a8e537a8da}\label{namespacempcr_1_1operations_1_1linear_a4d6e3d438dd9fcd8f4cdc5a8e537a8da}} 
\index{mpcr::operations::linear@{mpcr::operations::linear}!CrossProduct@{CrossProduct}}
\index{CrossProduct@{CrossProduct}!mpcr::operations::linear@{mpcr::operations::linear}}
\doxysubsubsection{\texorpdfstring{CrossProduct()}{CrossProduct()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void mpcr\+::operations\+::linear\+::\+Cross\+Product (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+InputA,  }\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+InputB,  }\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+Output,  }\item[{const bool \&}]{a\+TransposeA,  }\item[{const bool \&}]{a\+TransposeB,  }\item[{const bool \&}]{a\+Symmetrize = {\ttfamily true},  }\item[{const double \&}]{a\+Alpha = {\ttfamily 1},  }\item[{const double \&}]{a\+Beta = {\ttfamily 0} }\end{DoxyParamCaption})}



Calculate Cross\+Product of 2 M\+P\+CR Matrices performs\+: x \%$\ast$\% t(x) , x \%$\ast$\% t(y) , x \%$\ast$\% y , t(x) \%$\ast$\% y. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em a\+InputA} & M\+P\+CR Matrix \\
\hline
\mbox{\texttt{ in}}  & {\em a\+InputB} & M\+P\+CR Matrix \\
\hline
\mbox{\texttt{ out}}  & {\em a\+Output} & M\+P\+CR Matrix \\
\hline
\mbox{\texttt{ in}}  & {\em a\+TransposeA} & bool to indicate whether a\+InputA should be Transposed or not \\
\hline
\mbox{\texttt{ in}}  & {\em a\+TransposeB} & bool to indicate whether a\+InputB should be Transposed or not \\
\hline
\mbox{\texttt{ in}}  & {\em a\+Symmetrize} & if true and routine syrk is used, the upper matrix will be copied to the lower matrix \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_a4d6e3d438dd9fcd8f4cdc5a8e537a8da_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_a4d6e3d438dd9fcd8f4cdc5a8e537a8da_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacempcr_1_1operations_1_1linear_a52bdf8f12e8169bb9f88fe3b5aaf0aac}\label{namespacempcr_1_1operations_1_1linear_a52bdf8f12e8169bb9f88fe3b5aaf0aac}} 
\index{mpcr::operations::linear@{mpcr::operations::linear}!Eigen@{Eigen}}
\index{Eigen@{Eigen}!mpcr::operations::linear@{mpcr::operations::linear}}
\doxysubsubsection{\texorpdfstring{Eigen()}{Eigen()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void mpcr\+::operations\+::linear\+::\+Eigen (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+Input,  }\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+Output\+Values,  }\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} $\ast$}]{ap\+Output\+Vectors = {\ttfamily nullptr} }\end{DoxyParamCaption})}



Calculate Eigen Values and (optionally) Eigen Vectors. if(ap\+Output\+Vectors)= nullptr , only the values will be calculated. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em a\+Input} & M\+P\+CR Square Matrix \\
\hline
\mbox{\texttt{ out}}  & {\em a\+Output\+Values} & Eigen Values \\
\hline
\mbox{\texttt{ out}}  & {\em ap\+Output\+Vectors} & Eigen Vectors \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_a52bdf8f12e8169bb9f88fe3b5aaf0aac_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_a52bdf8f12e8169bb9f88fe3b5aaf0aac_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacempcr_1_1operations_1_1linear_ad56ba3c059d0ecb871efdad87bc10049}\label{namespacempcr_1_1operations_1_1linear_ad56ba3c059d0ecb871efdad87bc10049}} 
\index{mpcr::operations::linear@{mpcr::operations::linear}!IsSymmetric@{IsSymmetric}}
\index{IsSymmetric@{IsSymmetric}!mpcr::operations::linear@{mpcr::operations::linear}}
\doxysubsubsection{\texorpdfstring{IsSymmetric()}{IsSymmetric()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void mpcr\+::operations\+::linear\+::\+Is\+Symmetric (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+Input,  }\item[{bool \&}]{a\+Output }\end{DoxyParamCaption})}



Check if a Matrix Is Symmetric. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em a\+Input} & M\+P\+CR Matrix \\
\hline
\mbox{\texttt{ out}}  & {\em a\+Output} & true if symmetric ,false otherwise \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_ad56ba3c059d0ecb871efdad87bc10049_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_ad56ba3c059d0ecb871efdad87bc10049_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacempcr_1_1operations_1_1linear_a3dcaf6bd7a11a06db70d4e1097af99b4}\label{namespacempcr_1_1operations_1_1linear_a3dcaf6bd7a11a06db70d4e1097af99b4}} 
\index{mpcr::operations::linear@{mpcr::operations::linear}!Norm@{Norm}}
\index{Norm@{Norm}!mpcr::operations::linear@{mpcr::operations::linear}}
\doxysubsubsection{\texorpdfstring{Norm()}{Norm()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void mpcr\+::operations\+::linear\+::\+Norm (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+Input,  }\item[{const std\+::string \&}]{a\+Type,  }\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+Output }\end{DoxyParamCaption})}



Computes a matrix norm of a\+Input. The norm can be the one (\char`\"{}\+O\char`\"{}) norm, the infinity (\char`\"{}\+I\char`\"{}) norm, the Frobenius (\char`\"{}\+F\char`\"{}) norm, or the maximum modulus (\char`\"{}\+M\char`\"{}) among elements of a matrix. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em a\+Input} & M\+P\+CR Matrix \\
\hline
\mbox{\texttt{ in}}  & {\em a\+Type} & Type of Norm ( O , 1 , I , F, M) \\
\hline
\mbox{\texttt{ out}}  & {\em a\+Output} & Norm Value \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_a3dcaf6bd7a11a06db70d4e1097af99b4_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_a3dcaf6bd7a11a06db70d4e1097af99b4_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacempcr_1_1operations_1_1linear_a77142d0bbe9c5b3409bf89ea97f74818}\label{namespacempcr_1_1operations_1_1linear_a77142d0bbe9c5b3409bf89ea97f74818}} 
\index{mpcr::operations::linear@{mpcr::operations::linear}!QRDecomposition@{QRDecomposition}}
\index{QRDecomposition@{QRDecomposition}!mpcr::operations::linear@{mpcr::operations::linear}}
\doxysubsubsection{\texorpdfstring{QRDecomposition()}{QRDecomposition()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void mpcr\+::operations\+::linear\+::\+Q\+R\+Decomposition (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+InputA,  }\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+Output\+Qr,  }\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+Output\+Qraux,  }\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+Output\+Pivot,  }\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+Rank,  }\item[{const double \&}]{a\+Tolerance = {\ttfamily 1e-\/07} }\end{DoxyParamCaption})}



Computes the QR decomposition of a matrix. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em a\+InputA} & M\+P\+CR Matrix \\
\hline
\mbox{\texttt{ out}}  & {\em a\+Output\+Qr} & a M\+P\+CR Matrix with the same dimensions as a\+InputA. The upper triangle contains the decomposition and the lower triangle contains information of the decomposition (stored in compact form) \\
\hline
\mbox{\texttt{ out}}  & {\em a\+Output\+Qraux} & a vector of length ncol(a\+Input\+A) which contains additional information on Q \\
\hline
\mbox{\texttt{ out}}  & {\em a\+Output\+Pivot} & information on the pivoting strategy used during the decomposition \\
\hline
\mbox{\texttt{ out}}  & {\em a\+Rank} & the rank of a\+InputA ,always full rank in the L\+A\+P\+A\+CK. \\
\hline
\mbox{\texttt{ in}}  & {\em a\+Tolerance} & the tolerance for detecting linear dependencies in the columns of a\+InputA \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_a77142d0bbe9c5b3409bf89ea97f74818_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_a77142d0bbe9c5b3409bf89ea97f74818_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacempcr_1_1operations_1_1linear_a27b933e2aebb6707f2b4ad8a843fa2ee}\label{namespacempcr_1_1operations_1_1linear_a27b933e2aebb6707f2b4ad8a843fa2ee}} 
\index{mpcr::operations::linear@{mpcr::operations::linear}!QRDecompositionQ@{QRDecompositionQ}}
\index{QRDecompositionQ@{QRDecompositionQ}!mpcr::operations::linear@{mpcr::operations::linear}}
\doxysubsubsection{\texorpdfstring{QRDecompositionQ()}{QRDecompositionQ()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void mpcr\+::operations\+::linear\+::\+Q\+R\+DecompositionQ (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+InputA,  }\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+InputB,  }\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+Output,  }\item[{const bool \&}]{a\+Complete }\end{DoxyParamCaption})}



Returns part or all of Q, the order-\/nrow(X) orthogonal (unitary) transformation represented by qr. If complete is T\+R\+UE, Q has nrow(\+X) columns. If complete is F\+A\+L\+SE, Q has ncol(\+X) columns. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em a\+InputA} & M\+P\+CR Matrix QR \\
\hline
\mbox{\texttt{ in}}  & {\em a\+InputB} & M\+P\+CR Object Representing Q\+R\+A\+UX \\
\hline
\mbox{\texttt{ out}}  & {\em a\+Output} & returns Q. As M\+P\+CR Object. \\
\hline
\mbox{\texttt{ in}}  & {\em a\+Complete} & logical expression . Indicates whether an arbitrary orthogonal completion of the Q or X matrices is to be made, or whether the matrix is to be completed by binding zero-\/value rows beneath the square upper triangle. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_a27b933e2aebb6707f2b4ad8a843fa2ee_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_a27b933e2aebb6707f2b4ad8a843fa2ee_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacempcr_1_1operations_1_1linear_a903f45dc4c56fd063be9fcb41de60229}\label{namespacempcr_1_1operations_1_1linear_a903f45dc4c56fd063be9fcb41de60229}} 
\index{mpcr::operations::linear@{mpcr::operations::linear}!QRDecompositionQY@{QRDecompositionQY}}
\index{QRDecompositionQY@{QRDecompositionQY}!mpcr::operations::linear@{mpcr::operations::linear}}
\doxysubsubsection{\texorpdfstring{QRDecompositionQY()}{QRDecompositionQY()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void mpcr\+::operations\+::linear\+::\+Q\+R\+Decomposition\+QY (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+InputA,  }\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+InputB,  }\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+InputC,  }\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+Output,  }\item[{const bool \&}]{a\+Transpose }\end{DoxyParamCaption})}



Returns part or all of Q, the order-\/nrow(X) orthogonal (unitary) transformation represented by qr. If complete is T\+R\+UE, Q has nrow(\+X) columns. If complete is F\+A\+L\+SE, Q has ncol(\+X) columns. and each column of Q is multiplied by the corresponding value in Dvec. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em a\+InputA} & M\+P\+CR Matrix \\
\hline
\mbox{\texttt{ in}}  & {\em a\+InputB} & M\+P\+CR Object Representing Q\+R\+A\+UX \\
\hline
\mbox{\texttt{ in}}  & {\em a\+InputC} & M\+P\+CR Object Representing D\+Vec \\
\hline
\mbox{\texttt{ out}}  & {\em a\+Output} & returns Q. As M\+P\+CR Object. \\
\hline
\mbox{\texttt{ in}}  & {\em a\+Complete} & logical expression . Indicates whether an arbitrary orthogonal completion of the Q or X matrices is to be made, or whether the matrix is to be completed by binding zero-\/value rows beneath the square upper triangle. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_a903f45dc4c56fd063be9fcb41de60229_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_a903f45dc4c56fd063be9fcb41de60229_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacempcr_1_1operations_1_1linear_ac609806ecdb032bdfbca40e7ac8e6d5c}\label{namespacempcr_1_1operations_1_1linear_ac609806ecdb032bdfbca40e7ac8e6d5c}} 
\index{mpcr::operations::linear@{mpcr::operations::linear}!QRDecompositionR@{QRDecompositionR}}
\index{QRDecompositionR@{QRDecompositionR}!mpcr::operations::linear@{mpcr::operations::linear}}
\doxysubsubsection{\texorpdfstring{QRDecompositionR()}{QRDecompositionR()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void mpcr\+::operations\+::linear\+::\+Q\+R\+DecompositionR (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+InputA,  }\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+Output,  }\item[{const bool \&}]{a\+Complete }\end{DoxyParamCaption})}



returns R. This may be pivoted, The number of rows of R is either nrow(a\+Input\+A) or ncol(a\+Input\+A) (and may depend on whether complete is T\+R\+UE or F\+A\+L\+SE). 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em a\+InputA} & M\+P\+CR Matrix \\
\hline
\mbox{\texttt{ out}}  & {\em a\+Output} & returns R. This may be pivoted. As M\+P\+CR Object. \\
\hline
\mbox{\texttt{ in}}  & {\em a\+Complete} & logical expression . Indicates whether an arbitrary orthogonal completion of the Q or X matrices is to be made, or whether the matrix is to be completed by binding zero-\/value rows beneath the square upper triangle. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_ac609806ecdb032bdfbca40e7ac8e6d5c_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_ac609806ecdb032bdfbca40e7ac8e6d5c_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacempcr_1_1operations_1_1linear_ad3df9b11fb2ef85bb83b45fa48e1b220}\label{namespacempcr_1_1operations_1_1linear_ad3df9b11fb2ef85bb83b45fa48e1b220}} 
\index{mpcr::operations::linear@{mpcr::operations::linear}!ReciprocalCondition@{ReciprocalCondition}}
\index{ReciprocalCondition@{ReciprocalCondition}!mpcr::operations::linear@{mpcr::operations::linear}}
\doxysubsubsection{\texorpdfstring{ReciprocalCondition()}{ReciprocalCondition()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void mpcr\+::operations\+::linear\+::\+Reciprocal\+Condition (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+Input,  }\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+Output,  }\item[{const std\+::string \&}]{a\+Norm,  }\item[{const bool \&}]{a\+Triangle }\end{DoxyParamCaption})}



Estimate the reciprocal of the condition number of a matrix. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em a\+Input} & M\+P\+CR Matrix \\
\hline
\mbox{\texttt{ out}}  & {\em a\+Output} & M\+P\+CR Vector containing one element which is an estimate of the reciprocal condition number of a\+Input. \\
\hline
\mbox{\texttt{ in}}  & {\em a\+Norm} & character string indicating the type of norm to be used in the estimate. The default is \char`\"{}\+O\char`\"{} for the 1-\/norm (\char`\"{}\+O\char`\"{} is equivalent to \char`\"{}1\char`\"{}). For sparse matrices, when use\+Inv=T\+R\+UE, norm can be any of the kinds allowed for norm; otherwise, the other possible value is \char`\"{}\+I\char`\"{} for the infinity norm. \\
\hline
\mbox{\texttt{ in}}  & {\em a\+Triangle} & Bool if true,Only the lower triangle will be used. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_ad3df9b11fb2ef85bb83b45fa48e1b220_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_ad3df9b11fb2ef85bb83b45fa48e1b220_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacempcr_1_1operations_1_1linear_adbbaafc06cebed29879351524a5982da}\label{namespacempcr_1_1operations_1_1linear_adbbaafc06cebed29879351524a5982da}} 
\index{mpcr::operations::linear@{mpcr::operations::linear}!Solve@{Solve}}
\index{Solve@{Solve}!mpcr::operations::linear@{mpcr::operations::linear}}
\doxysubsubsection{\texorpdfstring{Solve()}{Solve()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void mpcr\+::operations\+::linear\+::\+Solve (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+InputA,  }\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+InputB,  }\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+Output,  }\item[{const bool \&}]{a\+Single }\end{DoxyParamCaption})}



Solves the equation AX=B. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em a\+InputA} & M\+P\+CR Matrix A \\
\hline
\mbox{\texttt{ in}}  & {\em a\+InputB} & M\+P\+CR Matrix X \\
\hline
\mbox{\texttt{ out}}  & {\em a\+Output} & M\+P\+CR Matrix B \\
\hline
\mbox{\texttt{ in}}  & {\em a\+Single} & if true only a\+InputA will be used and for X t(\+A) will be used. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_adbbaafc06cebed29879351524a5982da_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_adbbaafc06cebed29879351524a5982da_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacempcr_1_1operations_1_1linear_a9085cca6610c2c87cdf93eaf781ef893}\label{namespacempcr_1_1operations_1_1linear_a9085cca6610c2c87cdf93eaf781ef893}} 
\index{mpcr::operations::linear@{mpcr::operations::linear}!SVD@{SVD}}
\index{SVD@{SVD}!mpcr::operations::linear@{mpcr::operations::linear}}
\doxysubsubsection{\texorpdfstring{SVD()}{SVD()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void mpcr\+::operations\+::linear\+::\+S\+VD (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+InputA,  }\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+OutputS,  }\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+OutputU,  }\item[{\mbox{\hyperlink{classDataType}{Data\+Type}} \&}]{a\+OutputV,  }\item[{const size\+\_\+t \&}]{a\+Nu,  }\item[{const size\+\_\+t \&}]{a\+Nv,  }\item[{const bool \&}]{a\+Transpose = {\ttfamily true} }\end{DoxyParamCaption})}



Compute the singular-\/value decomposition of a rectangular matrix. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em a\+InputA} & M\+P\+CR Matrix \\
\hline
\mbox{\texttt{ out}}  & {\em a\+OutputS} & an M\+P\+CR Object containing the singular values of a\+InputA, of length min(n, p). \\
\hline
\mbox{\texttt{ out}}  & {\em a\+OutputU} & a M\+P\+CR Matrix whose columns contain the left singular vectors of a\+InputA, present if nu $>$ 0. Dimension c(m, nu). \\
\hline
\mbox{\texttt{ out}}  & {\em a\+OutputV} & a M\+P\+CR Matrix whose columns contain the right singular vectors of a\+InputA, present if nv $>$ 0. Dimension c(n, nv). \\
\hline
\mbox{\texttt{ in}}  & {\em a\+Nu} & the number of left singular vectors to be computed. This must between 0 and m = nrow(a\+Input\+A). \\
\hline
\mbox{\texttt{ in}}  & {\em a\+Nv} & the number of right singular vectors to be computed. This must be between 0 and n = ncol(a\+Input\+A). \\
\hline
\mbox{\texttt{ in}}  & {\em a\+Transpose} & Bool if true, a\+OutputV will contain V ,otherwise VT \\
\hline
\end{DoxyParams}
Will be transposed at the end in case of svdHere is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_a9085cca6610c2c87cdf93eaf781ef893_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_a9085cca6610c2c87cdf93eaf781ef893_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacempcr_1_1operations_1_1linear_a5c8f7cdb592e0cb4a820d88af7105d22}\label{namespacempcr_1_1operations_1_1linear_a5c8f7cdb592e0cb4a820d88af7105d22}} 
\index{mpcr::operations::linear@{mpcr::operations::linear}!TileCholesky@{TileCholesky}}
\index{TileCholesky@{TileCholesky}!mpcr::operations::linear@{mpcr::operations::linear}}
\doxysubsubsection{\texorpdfstring{TileCholesky()}{TileCholesky()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classMPCRTile}{M\+P\+C\+R\+Tile}} $\ast$ mpcr\+::operations\+::linear\+::\+Tile\+Cholesky (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classMPCRTile}{M\+P\+C\+R\+Tile}} \&}]{a\+Matrix,  }\item[{const bool \&}]{a\+Over\+Write\+Input = {\ttfamily true},  }\item[{const unsigned int \&}]{a\+Num\+Threads = {\ttfamily 1} }\end{DoxyParamCaption})}



Calculate Cholesky decomposition for Tiled-\/\+Symmetric Matrix. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em a\+Matrix} & M\+P\+CR Matrix \\
\hline
\mbox{\texttt{ in}}  & {\em a\+Over\+Write\+Input} & if true , the input will be overwritten with the output,otherwise a new copy will be created. \\
\hline
\mbox{\texttt{ in}}  & {\em a\+Num\+Threads} & int to decide the number of threads used in Open\+MP, default = 1 (sequential) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{classMPCRTile}{M\+P\+C\+R\+Tile}} Matrix containing decomposition result. 
\end{DoxyReturn}
potrf

trsm

syrk

gemmHere is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_a5c8f7cdb592e0cb4a820d88af7105d22_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=339pt]{namespacempcr_1_1operations_1_1linear_a5c8f7cdb592e0cb4a820d88af7105d22_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacempcr_1_1operations_1_1linear_abf947d90eb7b44b63653c9078e7f41a5}\label{namespacempcr_1_1operations_1_1linear_abf947d90eb7b44b63653c9078e7f41a5}} 
\index{mpcr::operations::linear@{mpcr::operations::linear}!TileGemm@{TileGemm}}
\index{TileGemm@{TileGemm}!mpcr::operations::linear@{mpcr::operations::linear}}
\doxysubsubsection{\texorpdfstring{TileGemm()}{TileGemm()}}
{\footnotesize\ttfamily void mpcr\+::operations\+::linear\+::\+Tile\+Gemm (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classMPCRTile}{M\+P\+C\+R\+Tile}} \&}]{a\+InputA,  }\item[{\mbox{\hyperlink{classMPCRTile}{M\+P\+C\+R\+Tile}} \&}]{a\+InputB,  }\item[{\mbox{\hyperlink{classMPCRTile}{M\+P\+C\+R\+Tile}} \&}]{a\+InputC,  }\item[{const bool \&}]{a\+TransposeA = {\ttfamily false},  }\item[{const bool \&}]{a\+TransposeB = {\ttfamily false},  }\item[{const double \&}]{a\+Alpha = {\ttfamily 1},  }\item[{const double \&}]{a\+Beta = {\ttfamily 1},  }\item[{const unsigned int \&}]{a\+Num\+Threads = {\ttfamily 1} }\end{DoxyParamCaption})}



Tiled-\/\+Matrix Multiplication of 2 M\+P\+CR Tile Matrices performs\+: C = alpha A $\ast$ B + beta C. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em a\+InputA} & \mbox{\hyperlink{classMPCRTile}{M\+P\+C\+R\+Tile}} Matrix \\
\hline
\mbox{\texttt{ in}}  & {\em a\+InputB} & \mbox{\hyperlink{classMPCRTile}{M\+P\+C\+R\+Tile}} Matrix \\
\hline
\mbox{\texttt{ in,out}}  & {\em a\+InputC} & \mbox{\hyperlink{classMPCRTile}{M\+P\+C\+R\+Tile}} Matrix \\
\hline
\mbox{\texttt{ in}}  & {\em a\+TransposeA} & flag to indicate whether A should be transposed \\
\hline
\mbox{\texttt{ in}}  & {\em a\+TransposeB} & flag to indicate whether B should be transposed \\
\hline
\mbox{\texttt{ in}}  & {\em a\+Alpha} & Factor multiplied to Matrix A \\
\hline
\mbox{\texttt{ in}}  & {\em a\+Beta} & Factor multiplied to Matrix C \\
\hline
\mbox{\texttt{ in}}  & {\em a\+Num\+Threads} & int to decide the number of threads used in Open\+MP, default = 1 (sequential) \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_abf947d90eb7b44b63653c9078e7f41a5_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=339pt]{namespacempcr_1_1operations_1_1linear_abf947d90eb7b44b63653c9078e7f41a5_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacempcr_1_1operations_1_1linear_a7d47126a1945fd0a6fd28af51ebd9f77}\label{namespacempcr_1_1operations_1_1linear_a7d47126a1945fd0a6fd28af51ebd9f77}} 
\index{mpcr::operations::linear@{mpcr::operations::linear}!TileTrsm@{TileTrsm}}
\index{TileTrsm@{TileTrsm}!mpcr::operations::linear@{mpcr::operations::linear}}
\doxysubsubsection{\texorpdfstring{TileTrsm()}{TileTrsm()}}
{\footnotesize\ttfamily void mpcr\+::operations\+::linear\+::\+Tile\+Trsm (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classMPCRTile}{M\+P\+C\+R\+Tile}} \&}]{a\+InputA,  }\item[{\mbox{\hyperlink{classMPCRTile}{M\+P\+C\+R\+Tile}} \&}]{a\+InputB,  }\item[{const char \&}]{a\+Side,  }\item[{const bool \&}]{a\+Upper\+Triangle,  }\item[{const bool \&}]{a\+Transpose,  }\item[{const double \&}]{a\+Alpha }\end{DoxyParamCaption})}



Solves a triangular matrix equation performs\+: op(\+A)$\ast$X=alpha$\ast$B X$\ast$op(A)=alpha$\ast$B. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em a\+InputA} & \mbox{\hyperlink{classMPCRTile}{M\+P\+C\+R\+Tile}} Matrix A \\
\hline
\mbox{\texttt{ in,out}}  & {\em a\+InputB} & \mbox{\hyperlink{classMPCRTile}{M\+P\+C\+R\+Tile}} Matrix B, X after returning. \\
\hline
\mbox{\texttt{ in}}  & {\em a\+Side} & \textquotesingle{}R for Right side , \textquotesingle{}L\textquotesingle{} for Left side \\
\hline
\mbox{\texttt{ in}}  & {\em a\+Upper\+Triangle} & What part of the matrix A is referenced, the opposite triangle being assumed to be zero. if true ,the Upper triangle is referenced. otherwise the Lower. \\
\hline
\mbox{\texttt{ in}}  & {\em a\+Transpose} & if true , the transpose of A is used. \\
\hline
\mbox{\texttt{ in}}  & {\em a\+Alpha} & Factor used for A , If alpha is zero, A is not accessed. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacempcr_1_1operations_1_1linear_a7d47126a1945fd0a6fd28af51ebd9f77_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=339pt]{namespacempcr_1_1operations_1_1linear_a7d47126a1945fd0a6fd28af51ebd9f77_icgraph}
\end{center}
\end{figure}
